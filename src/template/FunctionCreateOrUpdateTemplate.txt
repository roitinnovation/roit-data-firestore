createOrUpdate(items) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield global.instances.startTracer('firestore.createOrUpdate', async (span) => {
            try {
                let modelName = '';
                let validatorOptions;
                let ttlExpirationIn;
                let ttlUnit;
                if (!Array.isArray(items)) {
                    items = [items];
                }
                if (items.length > 500) {
                    throw new RepositoryBusinessException_1.RepositoryBusinessException(`To perform the create, the maximum number of elements is 500, size current: ${items.length}`, []);
                }
                const db = global.instances.globalDbFile.FirestoreInstance.getInstance();
                const { newDate } = global.instances.dateRef;
                const uuid = global.instances.uuid;
                const environmentUtil = global.instances.environmentUtil;
                const getTtlTimestamp = global.instances.getTtlTimestamp;
                const collection = db.collection('<COLLECTION_REPLACE>');
                const validatorDataHandle = global.instances.validatorDataHandle;
                const archiveService = yield global.instances.archiveService;
                const batch = db.batch();
                
                // Preparar IDs e buscar documentos existentes em lote (otimização)
                const itemsWithIds = items.map(item => {
                    if (!item.id) item.id = uuid();
                    return item;
                });
                
                const docRefs = itemsWithIds.map(item => collection.doc(item.id));
                const existingDocs = (archiveService.isEnabled() && docRefs.length > 0)
                    ? yield db.getAll(...docRefs)
                    : [];
                
                for (let i = 0; i < itemsWithIds.length; i++) {
                    const item = itemsWithIds[i];
                    yield validatorDataHandle.validateModel(modelName, item, validatorOptions);
                    
                    const docRef = docRefs[i];
                    let shouldUnarchive = false;
                    
                    // VERIFICAÇÃO DE DOCUMENTO ARQUIVADO
                    if (archiveService.isEnabled() && existingDocs[i]?.exists) {
                        const currentData = existingDocs[i].data();
                        const archivePath = global.instances.getArchivePath(currentData);
                        if (currentData && archivePath) {
                            const updateResult = yield archiveService.updateArchivedDocument(
                                '<COLLECTION_REPLACE>',
                                item.id,
                                item,
                                archivePath,
                                { unarchive: true }
                            );
                            
                            if (updateResult.result.success && updateResult.mergedData) {
                                if (updateResult.mergedData.createAt) {
                                    item.createAt = updateResult.mergedData.createAt;
                                    item.createTimestampAt = updateResult.mergedData.createTimestampAt;
                                }
                                const originalItem = Object.assign({}, item);
                                Object.assign(item, updateResult.mergedData, originalItem);
                                shouldUnarchive = true;
                            } else {
                                throw new Error('Failed to update archived document; aborting createOrUpdate to prevent inconsistent state and stale archive overwriting user changes.');
                            }
                        }
                    }
                    
                    if (!item.createAt) {
                        item.createAt = newDate();
                        item.createTimestampAt = new Date(item.createAt).getTime();
                    }
                    item.updateAt = newDate();
                    item.updateTimestampAt = new Date(item.updateAt).getTime();
                    item.lastServiceModify = process.env.SERVICE || 'PROJECT_UNDEFINED';
                    
                    // Preparar dados para persistir (consolidado)
                    const itemData = JSON.parse(JSON.stringify(item));
                    if (ttlExpirationIn && ttlUnit) {
                        itemData.ttlExpirationAt = getTtlTimestamp(ttlExpirationIn, ttlUnit);
                    }

                    if (shouldUnarchive && global.instances.markerKey()) {
                        const FieldValue = global.instances.FieldValue;
                        itemData[global.instances.markerKey()] = FieldValue.delete();
                    }

                    batch.set(docRef, itemData, { merge: true });
                }
                
                if (!environmentUtil.areWeTesting()) {
                    yield batch.commit();
                    yield this.revokeCache();
                } else {
                    console.log('It was decreed that it is being executed try, no operation or effective transaction will be performed');
                }
                
                span.setAttributes({
                    'firestore.operation.name': 'createOrUpdate',
                    'firestore.operation.size': items.length,
                    'firestore.collection.name': '<COLLECTION_REPLACE>',
                });
                return items;

            } catch (error) {
                span.setStatus({
                    code: 2,
                    message: error.message
                });
                span.recordException(error);
                throw error;
            }
        });
    });
}
