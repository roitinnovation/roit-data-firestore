delete(ids) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield global.instances.startTracer('firestore.delete', async (span) => {
            try {
                if (!ids) {
                    throw new RepositoryBusinessException_1.RepositoryBusinessException(`Id is required`, []);
                }
                if (!Array.isArray(ids)) {
                    ids = [ids];
                }
                if (ids.length > 500) {
                    throw new RepositoryBusinessException_1.RepositoryBusinessException(`To perform the delete, the maximum number of elements is 500, size current: ${ids.length}`, []);
                }
                const db = global.instances.globalDbFile.FirestoreInstance.getInstance();
                const environmentUtil = global.instances.environmentUtil;
                const archiveService = global.instances.archiveService;
                const batch = db.batch();
                const collection = db.collection('<COLLECTION_REPLACE>');
                
                // Verificar quais documentos estão arquivados antes de deletar
                const archivedDocIds = [];
                if (archiveService.isEnabled()) {
                    for (const id of ids) {
                        const docRef = collection.doc(id);
                        const doc = yield docRef.get();
                        if (doc.exists) {
                            const data = doc.data();
                            if (data && archiveService.isDocumentArchived(data)) {
                                archivedDocIds.push(id);
                            }
                        }
                    }
                }
                
                for (const id of ids) {
                    batch.delete(collection.doc(id));
                }
                
                if (!environmentUtil.areWeTesting()) {
                    yield batch.commit();
                    
                    // Deletar arquivos do Storage para documentos arquivados
                    if (archiveService.isEnabled() && archivedDocIds.length > 0) {
                        const deletePromises = archivedDocIds.map(docId => 
                            archiveService.deleteArchivedDocument('<COLLECTION_REPLACE>', docId)
                                .catch(err => {
                                    // Log erro mas não falha a operação principal
                                    console.warn(`Failed to delete archived file for ${docId}:`, err);
                                })
                        );
                        yield Promise.all(deletePromises);
                    }
                    
                    yield this.revokeCache();
                } else {
                    console.log('It was decreed that it is being executed try, no operation or effective transaction will be performed');
                }
                
                span.setAttributes({
                    'firestore.operation.name': 'delete',
                    'firestore.collection.name': '<COLLECTION_REPLACE>',
                    'firestore.collection.id': JSON.stringify(ids),
                    'firestore.archive.deleted': archivedDocIds.length
                });
                return ids;
            } catch (error) {
                span.setStatus({
                    code: 2,
                    message: error.message
                });
                span.recordException(error);
                throw error;
            }
        });
    });
}
