findAll(paging) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield global.instances.startTracer('firestore.findAll', async (span) => {
            try {
                let repositoryClassName = '';
                let methodSignature = '';
                const db = global.instances.globalDbFile.FirestoreInstance.getInstance();
                const cacheResolver = global.instances.cacheResolver;
                const archiveService = yield global.instances.archiveService;
                const result = yield cacheResolver.getCacheResult(repositoryClassName, methodSignature, 'Any');
                if (result) {
                    return result;
                }
                const queryCreatorConfig = global.instances.queryCreatorConfig;
                const collection = db.collection('<COLLECTION_REPLACE>');
                const environmentUtil = global.instances.environmentUtil;
                if (environmentUtil.areWeTesting()) {
                    console.log('It was decreed that it is being executed try, no operation or effective transaction will be performed');
                    return [];
                }
                const { documentRef } = yield queryCreatorConfig.buildPaging(collection, paging, { showCount: false });
                const snapshot = yield documentRef.get();
                let items = [];
                snapshot.forEach(doc => {
                    items.push({ ...doc.data(), id: doc.id });
                });
                
                // VERIFICAÇÃO DE ARQUIVAMENTO PARA MÚLTIPLOS DOCUMENTOS
                if (archiveService.isEnabled()) {
                    const archivedIndexes = [];
                    items.forEach((item, index) => {
                        if (archiveService.isDocumentArchived(item)) {
                            archivedIndexes.push(index);
                        }
                    });
                    
                    if (archivedIndexes.length > 0) {
                        const recoveryPromises = archivedIndexes.map(index => 
                            archiveService.getArchivedDocument('<COLLECTION_REPLACE>', items[index])
                                .then(archivedData => ({ index, data: archivedData }))
                        );
                        
                        const recoveredResults = yield Promise.all(recoveryPromises);
                        
                        // Substituir itens arquivados pelos recuperados (O(n) em vez de O(n²))
                        for (const { index, data } of recoveredResults) {
                            if (data) {
                                items[index] = { ...items[index], ...data };
                            }
                        }
                    }
                }
                
                yield cacheResolver.cacheResult(repositoryClassName, methodSignature, items, 'Any');
                const firestoreReadAuditResolver = global.instances.firestoreReadAuditResolver;
                yield firestoreReadAuditResolver.persistFirestoreRead({
                    collection: '<COLLECTION_REPLACE>',
                    repositoryClassName,
                    functionSignature: methodSignature,
                    queryResult: items
                });
                span.setAttributes({
                    'firestore.operation.name': 'findAll',
                    'firestore.collection.name': '<COLLECTION_REPLACE>',
                    'firestore.operation.size': items.length
                });
                return items;
            } catch (error) {
                span.setStatus({
                    code: 2,
                    message: error.message
                });
                span.recordException(error);
                throw error;
            }
        });
    });
}
