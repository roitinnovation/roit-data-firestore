async function(<params_replace>) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield global.instances.startTracer('firestore.query', async (span) => {
            try {
                if (<params_validator_replace>) {
                    throw new Error('All parameters required, ref..: <params_replace>');
                }

                const repositoryClassName = '<repositoryClassName_value>';
                const methodSignature = '<methodSignature_value>';

                const db = global.instances.globalDbFile.FirestoreInstance.getInstance();
                const cacheResolver = global.instances.cacheResolver;
                const firestoreReadAuditResolver = global.instances.firestoreReadAuditResolver;
                const environmentUtil = global.instances.environmentUtil;
                const archiveService = await global.instances.archiveService;
                
                if (environmentUtil.areWeTesting()) {
                    console.log('It was decreed that it is being executed try, no operation or effective transaction will be performed');
                    return [];
                }
                
                const result = await cacheResolver.getCacheResult(repositoryClassName, methodSignature, <params_replace>);
                
                if (result) {
                    return result;
                }

                const collection = db.collection('<collection_name_replace>');

                if (Number(process.env.FIRESTORE_DEBUG)) {
                    console.debug('[DEBUG] Executing query >', "<query_predicate_replace>");
                }

                const collectionRef = collection<query_predicate_replace>;
                const { documentRef } = await global.instances.queryCreatorConfig.buildPaging(collectionRef, paging, { showCount: false });
                const snapshot = await documentRef.get();

                let items = [];
                snapshot.forEach(doc => {
                    items.push({ ...doc.data(), id: doc.id });
                });

                // VERIFICAÇÃO DE ARQUIVAMENTO PARA DOCUMENTOS RETORNADOS
                if (archiveService.isEnabled()) {
                    const archivedItems = items.filter(item => archiveService.isDocumentArchived(item));
                    
                    if (archivedItems.length > 0) {
                        const recoveryPromises = archivedItems.map(item => {
                            return archiveService.getArchivedDocument('<collection_name_replace>', item)
                                .then(archivedData => archivedData ? { ...item, ...archivedData } : item)
                                .catch(() => item); // Fallback para stub se falhar
                        });
                        
                        const recoveredItems = await Promise.all(recoveryPromises);
                        
                        // Substituir itens arquivados pelos recuperados
                        const recoveredMap = new Map(recoveredItems.map(item => [item.id, item]));
                        items = items.map(item => {
                            if (archiveService.isDocumentArchived(item)) {
                                return recoveredMap.get(item.id) || item;
                            }
                            return item;
                        });
                    }
                }

                await cacheResolver.cacheResult(repositoryClassName, methodSignature, items, <params_replace>);

                await firestoreReadAuditResolver.persistFirestoreRead({
                    collection: '<collection_name_replace>',
                    repositoryClassName,
                    functionSignature: methodSignature,
                    params: <params_replace>,
                    queryResult: items
                });

                span.setAttributes({
                    'firestore.operation.name': 'query',
                    'firestore.operation.query': "<query_predicate_replace>",
                    'firestore.collection.name': '<collection_name_replace>',
                    'firestore.operation.size': items.length
                });

                if (<is_one_row>) {
                    return items[0];
                }

                return items;
            } catch (error) {
                span.setStatus({
                    code: 2,
                    message: error.message
                });
                span.recordException(error);
                throw error;
            }
        });
    });
}
