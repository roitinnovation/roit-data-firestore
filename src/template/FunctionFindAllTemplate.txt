findAll(paging) {
    return __awaiter(this, void 0, void 0, function* () {
        let repositoryClassName = '';
        let methodSignature = '';
        const db = global.instances.globalDbFile.FirestoreInstance.getInstance();
        const cacheResolver = global.instances.cacheResolver;
        const archiveService = yield global.instances.archiveService;
        
        const result = yield cacheResolver.getCacheResult(repositoryClassName, methodSignature, 'Any');
        if (result) {
            return result;
        }
        
        const queryCreatorConfig = global.instances.queryCreatorConfig;
        const collection = db.collection('<COLLECTION_REPLACE>');
        const environmentUtil = global.instances.environmentUtil;
        
        if (environmentUtil.areWeTesting()) {
            console.log('It was decreed that it is being executed try, no operation or effective transaction will be performed');
            return [];
        }

        let { documentRef } = yield queryCreatorConfig.buildPaging(collection, paging, { showCount: false });
        const snapshot = yield documentRef.get();
        let items = new Array;

        snapshot.forEach(doc => {
            const data = doc.data();
            items.push(Object.assign({}, data));
        });

        // VERIFICAÇÃO DE ARQUIVAMENTO PARA MÚLTIPLOS DOCUMENTOS
        const archivedItems = items.filter(item => archiveService.isDocumentArchived(item));
        if (archivedItems.length > 0) {
            const recoveryPromises = archivedItems.map((item) => {
                return archiveService.getArchivedDocument('<COLLECTION_REPLACE>', item)
                    .then(archivedData => archivedData ? { ...item, ...archivedData } : item);
            });
            
            const recoveredItems = yield Promise.all(recoveryPromises);
            
            // Substituir itens arquivados pelos recuperados
            items = items.map(item => {
                if (archiveService.isDocumentArchived(item)) {
                    return recoveredItems.find(recovered => recovered.id === item.id) || item;
                }
                return item;
            });
        }

        yield cacheResolver.cacheResult(repositoryClassName, methodSignature, items, 'Any');
        const firestoreReadAuditResolver = global.instances.firestoreReadAuditResolver;
        yield firestoreReadAuditResolver.persistFirestoreRead({
            collection: '<COLLECTION_REPLACE>',
            repositoryClassName,
            functionSignature: methodSignature,
            queryResult: items
        });
        return items;
    });
}